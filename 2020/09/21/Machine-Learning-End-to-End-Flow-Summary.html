<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Machine Learning End To End Flow Summary</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-09-21T00:00:00-05:00" itemprop="datePublished">
        Sep 21, 2020
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      4 min read
    
</span></p>

    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>The blog assumes the reader knows some basic Machine Learning terms.</p>

<p>This Summary post should be read along with the below blog post</p>

<p><a href="https://mrg-ai.github.io/blog/2020/09/20/ML_EndToEnd_usingCAHousingDataset.html">https://mrg-ai.github.io/blog/2020/09/20/ML_EndToEnd_usingCAHousingDataset.html</a></p>

<h1 id="get-the-data">Get the data</h1>

<ul>
  <li>
    <p>This could be via files or from a database. Try to get the data into a pandas dataframe.</p>
  </li>
  <li>
    <p>That is the best format to do further data exploration.</p>
  </li>
  <li>
    <p>Use head(), info(), describe() methods to look at the data and column/column type information</p>
  </li>
  <li>
    <p>Using matplotlib visualize the data via histograms for numerical columns</p>
  </li>
  <li>
    <p>For Categorical columns, find the unique values using value_counts()</p>
  </li>
</ul>

<h1 id="split-the-data-into-training-and-test">Split the data into Training and Test</h1>

<ul>
  <li>
    <p>Splitting the data can be random using a random seed using sklearns test_train_split class</p>
  </li>
  <li>
    <p>Get the labels into a different dataframe for using during prediction.</p>
  </li>
  <li>
    <p>However, in reality we should split using some unique column in the data (if available)</p>
  </li>
  <li>
    <p>We can create such column if that is possible by using some combination of existing columns.</p>
  </li>
  <li>
    <p>Sometimes, we may also have to do a stratified data split i.e. data should be taken from the different “strata” of the data. For example – Low Income Grp, High Income Grp etc.</p>

    <ul>
      <li>StratifiedShuffleSplit class can be used along with some column which indicates the “strata”</li>
    </ul>
  </li>
</ul>

<h1 id="visualize-and-data-cleanup-of-the-training-data">Visualize and Data Cleanup of the training data</h1>

<ul>
  <li>
    <p>Use matplotlib and look at the training data in more detail.</p>
  </li>
  <li>
    <p>Create new attributes (new dataframe columns) from existing columns if possible</p>
  </li>
  <li>
    <p>Date columns can definitely be used to create new Day, Month, Quarter, Year etc (DatePart function)</p>
  </li>
  <li>
    <p>Clean the data for NULLs, Blanks etc through any of the below methods. Each method has its own implications and should be considered appropriately.</p>

    <ul>
      <li>
        <p>Drop such rows</p>
      </li>
      <li>
        <p>Use sklearn SimpleImputer to impute such NULLs with Median or Mean values</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>NOTE –</strong> SimpleImputer works only on Numerical columns and CategoricalEncoders work on Categorical columns. We generally create different dataframes for Numericals and Categoricals. There is another Class which can handle both together and we will look at it in next section.</p>
  </li>
  <li>
    <p>Handle the Categorical values i.e. convert them to Numbers</p>

    <ul>
      <li>
        <p>Ordinal Encoder Class for Ordinal (they have a relationship between them) Categories like <em>Low, Medium, High</em></p>
      </li>
      <li>
        <p>One Hot Encoder Class for categories which are Nominal (unrelated to one another) like List of State Names (CA, AZ, NY etc.)</p>
      </li>
      <li>
        <p>We can also create Custom Transformers to do some custom transformations. An example below. Using BaseEstimator and TransformerMixin classes we can get many existing sklearn methods in the Custom Transformer.</p>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>from sklearn.base import BaseEstimator<strong>,</strong> TransformerMixin</p>

  <p>rooms_ix<strong>,</strong> bedrooms_ix<strong>,</strong> population_ix<strong>,</strong> households_ix <strong>=</strong> 3<strong>,</strong> 4<strong>,</strong> 5<strong>,</strong> 6</p>

  <p><strong>class</strong> <strong>CombinedAttributesAdder(</strong>BaseEstimator<strong>,</strong> TransformerMixin<strong>):</strong></p>

  <p><strong>def</strong> __init__<strong>(</strong><em>self</em><strong>,</strong> add_bedrooms_per_room<strong>=True):</strong> <em># no *args or **kargs</em></p>

  <p><em>self</em><strong>.</strong>add_bedrooms_per_room <strong>=</strong> add_bedrooms_per_room</p>

  <p><strong>def</strong> <strong>fit(</strong><em>self</em><strong>,</strong> X<strong>,</strong> y<strong>=None):</strong></p>

  <p><strong>return</strong> <em>self</em> <em># nothing else to do</em></p>

  <p><strong>def</strong> <strong>transform(</strong><em>self</em><strong>,</strong> X<strong>):</strong></p>

  <p>rooms_per_household <strong>=</strong> X<strong>[:,</strong> rooms_ix<strong>]</strong> <strong>/</strong> X<strong>[:,</strong> households_ix<strong>]</strong></p>

  <p>population_per_household <strong>=</strong> X<strong>[:,</strong> population_ix<strong>]</strong> <strong>/</strong> X<strong>[:,</strong> households_ix<strong>]</strong></p>

  <p><strong>if</strong> <em>self</em><strong>.</strong>add_bedrooms_per_room<strong>:</strong></p>

  <p>bedrooms_per_room <strong>=</strong> X<strong>[:,</strong> bedrooms_ix<strong>]</strong> <strong>/</strong> X<strong>[:,</strong> rooms_ix<strong>]</strong></p>

  <p><strong>return</strong> np<strong>.</strong>c_<strong>[</strong>X<strong>,</strong> rooms_per_household<strong>,</strong> population_per_household<strong>,</strong></p>

  <p>bedrooms_per_room<strong>]</strong></p>

  <p><strong>else:</strong></p>

  <p><strong>return</strong> np<strong>.</strong>c_<strong>[</strong>X<strong>,</strong> rooms_per_household<strong>,</strong> population_per_household<strong>]</strong></p>

  <p>attr_adder <strong>=</strong> CombinedAttributesAdder<strong>(</strong>add_bedrooms_per_room<strong>=False)</strong></p>

  <p>housing_extra_attribs <strong>=</strong> attr_adder<strong>.</strong>transform<strong>(</strong>housing<strong>.</strong>values<strong>)</strong></p>
</blockquote>

<h1 id="feature-scaling">Feature Scaling</h1>

<ul>
  <li>
    <p>This is required because ML algorithms require the different numerical features to be on similar scales.</p>
  </li>
  <li>
    <p>Therefore, it is always a good practice to Scale the Numerical features.</p>
  </li>
  <li>
    <p>Min-Max Scaling (Normalization) can be achieved with MinMaxScaler Class. This will cause issues when the data has many outliers.</p>
  </li>
  <li>
    <p>Standardization can be achieved through StandardScaler Class. Less affected by outliers.</p>
  </li>
</ul>

<h1 id="pipelines">Pipelines</h1>

<ul>
  <li>
    <p>Since there are multiple steps we do as part of Data preprocessing, we should create a pipeline to do these transformations one after the another.</p>
  </li>
  <li>
    <p>The output of one becomes input to another and so on.</p>
  </li>
  <li>
    <p>A pipeline for numerical attributes can look like below</p>
  </li>
</ul>

<blockquote>
  <p>num_pipeline <strong>=</strong> Pipeline<strong>([</strong></p>

  <p><strong>(</strong>‘imputer’<strong>,</strong> SimpleImputer<strong>(</strong>strategy<strong>=</strong>“median”<strong>)),</strong></p>

  <p><strong>(</strong>‘attribs_adder’<strong>,</strong> CombinedAttributesAdder<strong>()),</strong></p>

  <p><strong>(</strong>‘std_scaler’<strong>,</strong> StandardScaler<strong>()),</strong></p>

  <p><strong>])</strong></p>
</blockquote>

<ul>
  <li>
    <p>We can get the different transformations done for numerical columns as below using the pipeline defined above</p>

    <ul>
      <li>Dataframe_Transformed = num_pipeline.fit_transform(Dataframe[numerical attribute list])</li>
    </ul>
  </li>
  <li>
    <p>We can create a Full Pipeline for all attributes at once also. This would be ideal instead of having separate pipelines for Numericals and Categoricals.</p>
  </li>
  <li>
    <p>Below is such an example. We can use ColumnTransformer Class. Remainder keyword is to tell that any columns not covered in the num pipeline or cat pipeline should be passed through.</p>
  </li>
</ul>

<blockquote>
  <p>from sklearn.compose import ColumnTransformer</p>

  <p>num_attribs <strong>=</strong> <em>list</em><strong>(</strong>dataframe_num<strong>)</strong></p>

  <p>cat_attribs <strong>=</strong> <em>list</em><strong>(</strong>dataframe_cat<strong>)</strong></p>

  <p>num_attribs</p>

  <p>[‘List of Numeric Attributes’]</p>

  <p>cat_attribs</p>

  <p>[‘List of Categorical Attributes’]</p>

  <p>full_pipeline <strong>=</strong> ColumnTransformer<strong>([</strong></p>

  <p><strong>(</strong>“num”<strong>,</strong> num_pipeline<strong>,</strong> num_attribs<strong>),</strong></p>

  <p><strong>(</strong>“cat”<strong>,</strong> OneHotEncoder<strong>(),</strong> cat_attribs<strong>),</strong></p>

  <p><strong>],</strong> remainder<strong>=</strong>‘passthrough’<strong>)</strong></p>
</blockquote>

<ul>
  <li>
    <p>Dataframe_AllCols_Prepared = full_pipeline.fit_transform(Dataframe_AllCols)</p>
  </li>
  <li>
    <p>The data is now ready to be trained.</p>
  </li>
</ul>

<h1 id="evaluate-different-models">Evaluate Different Models</h1>

<ul>
  <li>
    <p>Evaluate the different models</p>
  </li>
  <li>
    <p>Calculate the cross validations score using K Fold Cross Validation</p>
  </li>
  <li>
    <p>Pick the model which best suits the data.</p>
  </li>
  <li>
    <p>Save the picked model using joblib.dump(model, ‘&lt;model_name&gt;.pkl’) as a pkl file.</p>
  </li>
  <li>
    <p>This can be later reloaded back using joblib.load()</p>
  </li>
</ul>

<h1 id="finetune-the-model">Finetune the Model</h1>

<ul>
  <li>
    <p>Finetune the models hyperparameters to finetune the model</p>
  </li>
  <li>
    <p>Using GridSearchCV or RandomizedSearchCV classes, we can get the best hyperparameters for the model.</p>
  </li>
</ul>

<h1 id="deploy-the-model">Deploy the Model</h1>

<ul>
  <li>
    <p>The model can be deployed on Cloud or can be exposed through a REST API and the model’s predict function can be used to evaluate the output by giving the necessary inputs.</p>
  </li>
  <li>
    <p>Note that the test input or any new input has to be transformed using the same data preprocessing pipeline before the model can predict the output using that input.</p>
  </li>
</ul>

<blockquote>
  <p>X_test_prepared <strong>=</strong> full_pipeline<strong>.</strong>transform<strong>(</strong>X_test<strong>)</strong></p>

  <p>final_predictions <strong>=</strong> final_model<strong>.</strong>predict<strong>(</strong>X_test_prepared<strong>)</strong></p>
</blockquote>

  </div><a class="u-url" href="/blog/2020/09/21/Machine-Learning-End-to-End-Flow-Summary.html" hidden></a>
</article>